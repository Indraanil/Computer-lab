#include <bits/stdc++.h>
using namespace std;
// Dijkstra using adjacency list and min-heap
// Graph: n nodes (0..n-1). edges: (to, weight).
vector<long long> dijkstra(int n, int src, vector<vector<pair<int,int>>> &adj){
    const long long INF = (1LL<<60);
    vector<long long> dist(n, INF);
    dist[src] = 0;
    priority_queue<pair<long long,int>, vector<pair<long long,int>>, greater<pair<long long,int>>> pq;
    pq.push({0, src});
    while(!pq.empty()){
        auto [d,u] = pq.top(); pq.pop();
        if(d > dist[u]) continue;            // stale entry
        for(auto &e : adj[u]){
            int v = e.first; int w = e.second;
            if(dist[v] > d + w){
                dist[v] = d + w;
                pq.push({dist[v], v});
            }
        }
    }
    return dist;
}

int main(){
    int n = 5; // example nodes 0..4
    vector<vector<pair<int,int>>> adj(n);
    // add edges: adj[u].push_back({v, weight});
    adj[0].push_back({1, 10});
    adj[0].push_back({3, 5});
    adj[1].push_back({2, 1});
    adj[3].push_back({1, 3});
    adj[3].push_back({2, 9});
    adj[3].push_back({4, 2});
    adj[4].push_back({2, 6});
    adj[2].push_back({4, 4});
    // run from source 0
    auto dist = dijkstra(n, 0, adj);
    for(int i=0;i<n;i++){
        if(dist[i] >= (1LL<<59)) cout << "INF\n"; else cout << dist[i] << '\n';
    }
    return 0;
}
